import { Question } from './types';

export const questions: Question[] = [
  {
    "id": 1,
    "topic": "Arrays and Slices",
    "question_text": "Что из перечисленного является ключевым отличием массива (array) от среза (slice) в Go?",
    "options": [
      "Длина массива является частью его типа, а у среза — нет.",
      "Срез всегда хранится на стеке, а массив — в куче.",
      "Массивы могут менять свой размер, а срезы — нет.",
      "Срезы передаются в функции по значению (копируются целиком), а массивы — по ссылке."
    ],
    "correct_options": [0],
    "explanation": "Главное отличие в том, что длина массива — это неотъемлемая часть его типа (например, `[3]int` и `[4]int` — разные типы). Длина среза не является частью его типа, что делает его более гибким."
  },
  {
    "id": 2,
    "topic": "Arrays and Slices",
    "question_text": "Что произойдет при передаче массива в функцию в Go?",
    "options": [
      "В функцию будет передан указатель на массив.",
      "Произойдет полное копирование всех элементов массива.",
      "Будет скопирован только заголовок массива.",
      "Массив будет перемещен в стек функции."
    ],
    "correct_options": [1],
    "explanation": "Массив в Go — это тип-значение (value type). При передаче в функцию создается полная копия массива, поэтому изменения внутри функции не затрагивают оригинал."
  },
  {
    "id": 3,
    "topic": "Arrays and Slices",
    "question_text": "Из каких полей состоит заголовок среза (slice header)?",
    "options": [
      "Указатель на данные, длина (len), емкость (cap).",
      "Указатель на данные, длина (len).",
      "Длина (len), емкость (cap).",
      "Указатель на данные, емкость (cap), тип элементов."
    ],
    "correct_options": [0],
    "explanation": "Заголовок среза состоит из трех компонентов: указателя на базовый массив, длины (количество видимых элементов) и емкости (общее количество доступных элементов от указателя до конца базового массива)."
  },
  {
    "id": 4,
    "topic": "Arrays and Slices",
    "question_text": "Сколько байт занимает заголовок среза на 64-битной архитектуре?",
    "options": [
      "8 байт",
      "16 байт",
      "24 байта",
      "Зависит от количества элементов в срезе."
    ],
    "correct_options": [2],
    "explanation": "На 64-битной архитектуре указатель, `len` (int) и `cap` (int) занимают по 8 байт каждый. Итого: 8 + 8 + 8 = 24 байта. Этот размер постоянен."
  },
  {
    "id": 5,
    "topic": "Arrays and Slices",
    "question_text": "Дан срез `s := []int{10, 20, 30, 40, 50}`. Что будет результатом операции `s1 := s[1:3]`?",
    "options": [
      "`len(s1)` будет 2, `cap(s1)` будет 4.",
      "`len(s1)` будет 2, `cap(s1)` будет 2.",
      "`len(s1)` будет 3, `cap(s1)` будет 5.",
      "`len(s1)` будет 2, `cap(s1)` будет 5."
    ],
    "correct_options": [0],
    "explanation": "Длина (len) равна `end - start` (3 - 1 = 2). Емкость (cap) равна `cap(original) - start` (5 - 1 = 4). Элементы: {20, 30}."
  },
  {
    "id": 6,
    "topic": "Arrays and Slices",
    "question_text": "Что делает функция `append` если емкость среза недостаточна для добавления новых элементов?",
    "options": [
      "Возвращает ошибку.",
      "Выделяет новый, больший базовый массив, копирует туда старые элементы и добавляет новые.",
      "Увеличивает размер существующего базового массива.",
      "Паникует."
    ],
    "correct_options": [1],
    "explanation": "Если емкости не хватает, `append` аллоцирует новый, более просторный массив, копирует в него содержимое старого массива и затем добавляет новые элементы. Указатель в заголовке среза начинает указывать на этот новый массив."
  },
  {
    "id": 7,
    "topic": "Arrays and Slices",
    "question_text": "Почему критически важно всегда использовать конструкцию `s = append(s, ...)`?",
    "options": [
      "Потому что `append` может вернуть заголовок среза, указывающий на совершенно новый базовый массив.",
      "Это просто стилистическое соглашение в Go.",
      "Потому что `append` всегда изменяет емкость среза.",
      "Без этого компилятор выдаст ошибку."
    ],
    "correct_options": [0],
    "explanation": "Если при добавлении элементов происходит реалокация, `append` создает новый базовый массив и возвращает новый заголовок среза, указывающий на него. Если не присвоить этот результат обратно переменной, она продолжит указывать на старый, меньший массив."
  },
  {
    "id": 8,
    "topic": "Strings and Runes",
    "question_text": "Что представляет собой строка (`string`) в Go 'под капотом'?",
    "options": [
      "Неизменяемый (immutable) срез байтов (`[]byte`).",
      "Срез рун (`[]rune`).",
      "Связанный список символов.",
      "Структуру с указателем на данные и емкостью."
    ],
    "correct_options": [0],
    "explanation": "Строка в Go — это неизменяемая последовательность байтов. Ее заголовок похож на заголовок среза, но содержит только указатель на данные и длину, без емкости."
  },
  {
    "id": 9,
    "topic": "Strings and Runes",
    "question_text": "Что вернет `len(\"привет\")`?",
    "options": [
      "6",
      "12",
      "Зависит от кодировки системы.",
      "Произойдет ошибка компиляции."
    ],
    "correct_options": [1],
    "explanation": "Функция `len()` для строк возвращает количество байтов. Кириллические символы в кодировке UTF-8 занимают по 2 байта, поэтому 6 символов * 2 байта = 12 байт."
  },
  {
    "id": 10,
    "topic": "Strings and Runes",
    "question_text": "Какой способ итерации по строке является идиоматичным и безопасным для работы с Unicode-символами?",
    "options": [
      "Цикл `for i := 0; i < len(s); i++`",
      "Цикл `for i, r := range s`",
      "Преобразование строки в `[]byte` и итерация по байтам.",
      "Использование сторонних библиотек."
    ],
    "correct_options": [1],
    "explanation": "Цикл `for ... range` применительно к строке специально спроектирован для корректной работы с UTF-8. В каждой итерации он декодирует следующий символ (руну) и возвращает его вместе с байтовым индексом начала этого символа."
  },
  {
    "id": 11,
    "topic": "Strings and Runes",
    "question_text": "Что такое `rune` в Go?",
    "options": [
      "Псевдоним для `int32`, представляющий кодовую точку Unicode.",
      "Псевдоним для `byte`.",
      "Структура для хранения многобайтных символов.",
      "Тип данных для неизменяемых строк."
    ],
    "correct_options": [0],
    "explanation": "`rune` — это псевдоним для `int32`. Он используется для представления одного символа (кодовой точки Unicode), независимо от того, сколькими байтами этот символ кодируется в UTF-8."
  },
  {
    "id": 12,
    "topic": "Maps",
    "question_text": "Что произойдет при попытке конкурентной записи в `map` из нескольких горутин без синхронизации?",
    "options": [
      "Программа скомпилируется, но во время выполнения произойдет паника.",
      "Программа не скомпилируется.",
      "Данные будут записаны в случайном порядке, но без ошибок.",
      "Только одна из операций записи будет успешной."
    ],
    "correct_options": [0],
    "explanation": "Обычный `map` в Go не является потокобезопасным. Одновременная запись (или запись и чтение) из разных горутин приводит к состоянию гонки (data race), которое обнаруживается рантаймом и вызывает панику."
  },
  {
    "id": 13,
    "topic": "Maps",
    "question_text": "Каков порядок итерации по элементам карты (`map`) в Go?",
    "options": [
      "Порядок вставки.",
      "Порядок, обратный вставке.",
      "Лексикографический порядок ключей.",
      "Порядок не гарантирован и является случайным."
    ],
    "correct_options": [3],
    "explanation": "Спецификация Go явно указывает, что порядок итерации по карте не гарантирован. Рантайм намеренно рандомизирует его, чтобы программисты не полагались на какой-либо определенный порядок."
  },
  {
    "id": 14,
    "topic": "Maps",
    "question_text": "Что такое 'бакет' (bucket) во внутренней реализации `map` в Go?",
    "options": [
      "Небольшая структура, хранящая до 8 пар ключ-значение.",
      "Один элемент карты.",
      "Указатель на ключ.",
      "Список всех ключей с одинаковым хешем."
    ],
    "correct_options": [0],
    "explanation": "Карта в Go состоит из массива бакетов. Каждый бакет — это структура, способная хранить до 8 пар ключ-значение, а также массив `tophash` для быстрого поиска и указатель на бакет переполнения."
  },
  {
    "id": 15,
    "topic": "Maps",
    "question_text": "Как в `map` решаются коллизии (когда два разных ключа получают один и тот же индекс бакета)?",
    "options": [
      "Методом цепочек переполнения (chaining).",
      "Методом открытой адресации.",
      "Путем перехеширования ключа.",
      "Путем увеличения размера карты."
    ],
    "correct_options": [0],
    "explanation": "Go использует метод цепочек. Если бакет заполнен, создается новый 'бакет переполнения' (overflow bucket), и он связывается с исходным бакетом, образуя связанный список бакетов для одного индекса."
  },
  {
    "id": 16,
    "topic": "Interfaces",
    "question_text": "Какое ключевое свойство характеризует интерфейсы в Go?",
    "options": [
      "Неявная реализация (утиная типизация).",
      "Явная реализация с помощью ключевого слова `implements`.",
      "Наследование реализаций от других интерфейсов.",
      "Возможность содержать поля данных."
    ],
    "correct_options": [0],
    "explanation": "Главная особенность интерфейсов в Go — неявная реализация. Любой тип, который реализует все методы интерфейса, автоматически удовлетворяет ему без каких-либо явных деклараций."
  },
  {
    "id": 17,
    "topic": "Interfaces",
    "question_text": "Что представляет собой переменная непустого интерфейса 'под капотом'?",
    "options": [
      "Структуру `iface` из двух указателей: на `itab` и на данные.",
      "Структуру `eface` из двух указателей: на тип и на данные.",
      "Один указатель на данные.",
      "Виртуальную таблицу методов."
    ],
    "correct_options": [0],
    "explanation": "Непустой интерфейс представлен структурой `iface`, состоящей из указателя на `itab` (таблицу интерфейса, содержащую информацию о паре тип-интерфейс и указатели на методы) и указателя на конкретное значение."
  },
  {
    "id": 18,
    "topic": "Interfaces",
    "question_text": "Что такое пустой интерфейс `interface{}` (или `any`)?",
    "options": [
      "Интерфейс без методов, которому удовлетворяет абсолютно любой тип.",
      "Тип, эквивалентный `nil`.",
      "Интерфейс, который может быть реализован только структурами.",
      "Устаревшая конструкция, замененная дженериками."
    ],
    "correct_options": [0],
    "explanation": "Пустой интерфейс `interface{}` (с Go 1.18 также `any`) не определяет ни одного метода. Поскольку требований нет, любой тип в Go ему удовлетворяет, что позволяет использовать его как универсальный контейнер для значений."
  },
  {
    "id": 19,
    "topic": "Memory Management",
    "question_text": "Что такое 'escape analysis' (анализ ухода в кучу)?",
    "options": [
      "Процесс, в ходе которого компилятор определяет, разместить переменную на стеке или в куче.",
      "Процесс поиска утечек памяти во время выполнения.",
      "Алгоритм, используемый сборщиком мусора для пометки живых объектов.",
      "Механизм защиты от выхода за пределы массива."
    ],
    "correct_options": [0],
    "explanation": "Escape analysis — это статический анализ, выполняемый компилятором для определения, может ли адрес переменной быть использован после завершения функции, в которой она создана. Если да, переменная 'уходит' в кучу, в противном случае размещается на более быстром стеке."
  },
  {
    "id": 20,
    "topic": "Memory Management",
    "question_text": "Какой алгоритм использует сборщик мусора (GC) в Go?",
    "options": [
      "Конкурентный трехцветный 'пометка и очистка' (mark-and-sweep).",
      "Подсчет ссылок (reference counting).",
      "Копирующий сборщик (copying collector).",
      "Генерационный сборщик (generational collector)."
    ],
    "correct_options": [0],
    "explanation": "Go использует конкурентный трехцветный алгоритм mark-and-sweep. Он спроектирован для работы параллельно с основной программой с очень короткими паузами 'Stop-The-World' (STW)."
  },
  {
    "id": 21,
    "topic": "Memory Management",
    "question_text": "Что такое 'Write Barrier' (барьер записи) в контексте GC Go?",
    "options": [
      "Механизм, предотвращающий ошибочное удаление живых объектов во время конкурентной фазы пометки.",
      "Защита памяти от записи из других процессов.",
      "Аппаратная функция процессора для атомарных операций.",
      "Команда, запрещающая запись в определенную область памяти."
    ],
    "correct_options": [0],
    "explanation": "Write Barrier — это код, вставляемый компилятором, который отслеживает изменения указателей в куче во время работы GC. Если 'черный' (уже обработанный) объект начинает ссылаться на 'белый' (еще не виденный), барьер 'серит' этот белый объект, чтобы GC его не пропустил и не удалил."
  },
  {
    "id": 22,
    "topic": "Concurrency",
    "question_text": "Что такое горутина (goroutine)?",
    "options": [
      "Легковесный, управляемый рантаймом 'поток выполнения'.",
      "Поток операционной системы (OS thread).",
      "Функция, которая всегда выполняется в фоновом потоке.",
      "Синоним для асинхронной функции."
    ],
    "correct_options": [0],
    "explanation": "Горутина — это не поток ОС, а гораздо более легковесная сущность, управляемая планировщиком Go. Можно запустить сотни тысяч горутин, которые будут выполняться на небольшом количестве системных потоков."
  },
  {
    "id": 23,
    "topic": "Concurrency",
    "question_text": "В чем разница между небуферизованным и буферизованным каналом?",
    "options": [
      "Запись в небуферизованный канал блокируется до появления читателя, а в буферизованный — только при заполнении буфера.",
      "Небуферизованные каналы быстрее буферизованных.",
      "В буферизованный канал можно отправлять данные любого типа, а в небуферизованный — только определенного.",
      "Небуферизованные каналы не могут быть закрыты."
    ],
    "correct_options": [0],
    "explanation": "Небуферизованный канал обеспечивает синхронизацию (рандеву) между отправителем и получателем. Буферизованный канал работает асинхронно, развязывая отправителя и получателя, пока в буфере есть место (для записи) или данные (для чтения)."
  },
  {
    "id": 24,
    "topic": "Concurrency",
    "question_text": "Что делает оператор `select`?",
    "options": [
      "Позволяет горутине ожидать операции на нескольких каналах одновременно.",
      "Выбирает самый быстрый канал для отправки данных.",
      "Создает группу каналов.",
      "Является аналогом `switch` для типов."
    ],
    "correct_options": [0],
    "explanation": "`select` блокируется до тех пор, пока одна из операций с каналами в его `case` не станет доступной. Если готовы несколько, выбирается одна случайным образом."
  },
  {
    "id": 25,
    "topic": "Concurrency",
    "question_text": "Что представляет собой модель GMP планировщика Go?",
    "options": [
      "Архитектуру из Горутин (G), Машинных потоков (M) и Процессоров (P).",
      "Модель управления памятью (Garbage, Memory, Pointers).",
      "Протокол сетевого взаимодействия (Go Messaging Protocol).",
      "Набор правил хорошего стиля программирования."
    ],
    "correct_options": [0],
    "explanation": "GMP — это архитектура планировщика Go. Он мультиплексирует множество Горутин (G) на небольшом количестве потоков ОС (M), используя Процессоры (P) как контекст выполнения."
  },
  {
    "id": 26,
    "topic": "Arrays and Slices",
    "question_text": "Можно ли сравнить два среза `s1` и `s2` с помощью оператора `==`?",
    "options": [
      "Нет, срезы можно сравнивать только с `nil`.",
      "Да, если они имеют одинаковую длину и емкость.",
      "Да, если они указывают на один и тот же базовый массив.",
      "Да, если все их элементы сравнимы."
    ],
    "correct_options": [0],
    "explanation": "Спецификация Go не позволяет напрямую сравнивать срезы с помощью `==`, так как это потребовало бы поэлементного сравнения, что может быть дорого. Единственное допустимое сравнение для среза — это `s == nil`."
  },
  {
    "id": 27,
    "topic": "Arrays and Slices",
    "question_text": "Что делает полная форма среза `a[start:end:max]`?",
    "options": [
      "Создает новый срез с длиной `end - start` и емкостью `max - start`.",
      "Создает новый срез с длиной `end - start` и емкостью `max`.",
      "Копирует элементы от `start` до `end` в новый массив максимальной длиной `max`.",
      "Это синтаксическая ошибка."
    ],
    "correct_options": [0],
    "explanation": "Полная форма среза позволяет явно контролировать емкость нового среза. Его `len` будет `end - start`, а `cap` — `max - start`. Это полезно для предотвращения нежелательных модификаций базового массива."
  },
  {
    "id": 28,
    "topic": "Strings and Runes",
    "question_text": "Выберите верные утверждения о строках в Go. (несколько вариантов)",
    "options": [
      "Строки неизменяемы (immutable).",
      "Заголовок строки содержит указатель на данные и длину.",
      "Передача строки в функцию — дешевая операция.",
      "Строка является срезом рун (`[]rune`)."
    ],
    "correct_options": [0, 1, 2],
    "explanation": "Строки в Go неизменяемы, их заголовок (16 байт на x64) содержит указатель и длину (без емкости), что делает их передачу эффективной. Строка — это срез байтов, а не рун."
  },
  {
    "id": 29,
    "topic": "Strings and Runes",
    "question_text": "Что произойдет при выполнении `runes := []rune(\"тест\")`?",
    "options": [
      "Будет создан новый массив из 4 элементов типа `int32`, и `runes` будет срезом, указывающим на него.",
      "`runes` будет указывать на тот же базовый массив, что и строка \"тест\".",
      "Произойдет ошибка, так как строки нельзя преобразовать в руны.",
      "Будет создан срез из 8 байтов."
    ],
    "correct_options": [0],
    "explanation": "Преобразование `string` в `[]rune` — это операция, которая аллоцирует новый массив. Рантайм декодирует каждый UTF-8 символ из строки в кодовую точку Unicode (`rune`, он же `int32`) и помещает в этот новый массив."
  },
  {
    "id": 30,
    "topic": "Maps",
    "question_text": "Для чего используется поле `tophash` в бакете карты?",
    "options": [
      "Для быстрой предварительной фильтрации ключей без их полного сравнения.",
      "Для хранения полного хеша ключа.",
      "Для связи с бакетом переполнения.",
      "Для рандомизации порядка итерации."
    ],
    "correct_options": [0],
    "explanation": "`tophash` хранит старшие 8 бит хеша каждого ключа в бакете. При поиске рантайм сначала быстро сравнивает эти байты, и только в случае совпадения переходит к дорогостоящему полному сравнению ключей."
  },
  {
    "id": 31,
    "topic": "Maps",
    "question_text": "Когда начинается процесс расширения карты?",
    "options": [
      "Когда среднее количество элементов на бакет (коэффициент загрузки) превышает 6.5.",
      "Когда в карте заканчиваются все бакеты.",
      "Когда происходит первая коллизия.",
      "Когда количество элементов в карте становится степенью двойки."
    ],
    "correct_options": [0],
    "explanation": "Расширение карты инициируется, когда ее коэффициент загрузки (load factor), вычисляемый как `count / (2^B)`, становится слишком высоким. Текущий порог в рантайме Go — 6.5."
  },
  {
    "id": 32,
    "topic": "Maps",
    "question_text": "В каком сценарии `sync.Map` будет производительнее, чем `map` с `sync.RWMutex`?",
    "options": [
      "Когда ключи в карте редко изменяются, но происходит очень много конкурентных чтений.",
      "Когда происходит очень много конкурентных записей и удалений.",
      "Во всех сценариях с конкурентным доступом.",
      "Только в однопоточных программах."
    ],
    "correct_options": [0],
    "explanation": "`sync.Map` оптимизирована для сценария 'записал один раз, читай много раз' (write-once, read-many). Она позволяет выполнять конкурентные чтения без блокировок для уже существующих ключей, что делает ее очень быстрой в этом случае."
  },
  {
    "id": 33,
    "topic": "Interfaces",
    "question_text": "Что такое `itab` (interface table)?",
    "options": [
      "Структура, связывающая конкретный тип с конкретным интерфейсом и хранящая указатели на реализации методов.",
      "Таблица всех интерфейсов в программе.",
      "Внутреннее представление пустого интерфейса.",
      "Синоним для виртуальной таблицы в C++."
    ],
    "correct_options": [0],
    "explanation": "`itab` — это сердце динамической диспетчеризации в Go. Она содержит информацию о паре (тип, интерфейс) и массив указателей на функции, который является реализацией виртуальной таблицы."
  },
  {
    "id": 34,
    "topic": "Interfaces",
    "question_text": "Что произойдет при вызове `val, ok := i.(MyType)` если переменная `i` интерфейсного типа не хранит значение типа `MyType`?",
    "options": [
      "`val` будет нулевым значением для `MyType`, `ok` будет `false`.",
      "Произойдет паника.",
      "Программа не скомпилируется.",
      "`val` будет `nil`, `ok` будет `false`."
    ],
    "correct_options": [0],
    "explanation": "Форма утверждения типа с двумя возвращаемыми значениями является безопасной. Если утверждение не удалось, паники не происходит. Вместо этого переменная `ok` получает значение `false`, а первая переменная (`val`) — нулевое значение для того типа, к которому пытались привести."
  },
  {
    "id": 35,
    "topic": "Memory Management",
    "question_text": "Каков минимальный начальный размер стека горутины в современных версиях Go?",
    "options": [
      "2 KB",
      "64 KB",
      "1 MB",
      "4 байта"
    ],
    "correct_options": [0],
    "explanation": "Стеки горутин начинаются с очень маленького размера, 2 КБ. Это позволяет создавать огромное количество горутин без значительного расхода памяти. При необходимости стек может динамически расти."
  },
  {
    "id": 36,
    "topic": "Memory Management",
    "question_text": "Что из перечисленного, скорее всего, приведет к 'уходу' переменной в кучу? (несколько вариантов)",
    "options": [
      "Возврат указателя на локальную переменную из функции.",
      "Отправка указателя на переменную в канал.",
      "Объявление локальной переменной базового типа (`int`, `bool`).",
      "Создание среза, размер которого известен на этапе компиляции."
    ],
    "correct_options": [0, 1],
    "explanation": "Возврат указателя или его отправка в канал делают переменную доступной за пределами ее первоначальной области видимости, поэтому компилятор вынужден разместить ее в куче. Локальные переменные с известным размером обычно остаются на стеке."
  },
  {
    "id": 37,
    "topic": "Concurrency",
    "question_text": "Что произойдет при чтении из закрытого канала?",
    "options": [
      "Чтение немедленно вернет нулевое значение для типа канала (если буфер пуст).",
      "Произойдет паника.",
      "Горутина заблокируется навсегда.",
      "Функция `<-ch` вернет ошибку."
    ],
    "correct_options": [0],
    "explanation": "Чтение из закрытого канала никогда не блокируется. Если в буфере еще были значения, они будут прочитаны. После этого каждое последующее чтение будет немедленно возвращать нулевое значение (`0`, `\"\"`, `nil` и т.д.)."
  },
  {
    "id": 38,
    "topic": "Concurrency",
    "question_text": "Что такое `work stealing` в планировщике Go?",
    "options": [
      "Механизм, при котором бездействующий процессор (P) 'крадет' горутины из очереди другого процессора.",
      "Способ принудительно завершить горутину.",
      "Оптимизация для уменьшения использования памяти горутинами.",
      "Атака, направленная на планировщик."
    ],
    "correct_options": [0],
    "explanation": "Work stealing — это стратегия балансировки нагрузки. Когда процессор P выполнил все горутины в своей локальной очереди и не нашел работы в глобальной, он пытается 'украсть' половину горутин у другого, случайного P, чтобы не простаивать."
  },
  {
    "id": 39,
    "topic": "System Design",
    "question_text": "Какой принцип SOLID нарушается, если один пакет отвечает за бизнес-логику, работу с базой данных и отправку email-сообщений?",
    "options": [
      "Принцип единственной ответственности (Single Responsibility Principle).",
      "Принцип открытости/закрытости (Open/Closed Principle).",
      "Принцип инверсии зависимостей (Dependency Inversion Principle).",
      "Принцип разделения интерфейса (Interface Segregation Principle)."
    ],
    "correct_options": [0],
    "explanation": "Принцип единственной ответственности гласит, что у модуля должна быть только одна причина для изменения. В данном случае у пакета их как минимум три: изменение бизнес-логики, смена БД, смена способа отправки email. Это явное нарушение SRP."
  },
  {
    "id": 40,
    "topic": "System Design",
    "question_text": "Какую проблему решает паттерн Circuit Breaker (Автоматический выключатель)?",
    "options": [
      "Предотвращает каскадные сбои, изолируя вызовы к неисправному сервису.",
      "Гарантирует доставку сообщений в распределенной системе.",
      "Управляет распределенными транзакциями.",
      "Обеспечивает безопасность сетевых соединений."
    ],
    "correct_options": [0],
    "explanation": "Основная цель Circuit Breaker — дать сбоящему сервису время на восстановление, не заваливая его повторными запросами, и защитить вызывающую систему от траты ресурсов на ожидание ответа, который, скорее всего, не придет или будет ошибочным."
  },
  {
    "id": 41,
    "topic": "Arrays and Slices",
    "question_text": "Дан массив `a := [5]int{1,2,3,4,5}`. Каким будет результат `s := a[:]`?",
    "options": [
      "Будет создан срез `s` с `len=5`, `cap=5`, указывающий на базовый массив `a`.",
      "Будет создан новый массив `s` с копией всех элементов `a`.",
      "Произойдет ошибка компиляции.",
      "Будет создан срез `s` с `len=5` и `cap=0`."
    ],
    "correct_options": [0],
    "explanation": "Операция `a[:]` создает срез, который является 'видом' на весь массив `a`. Длина и емкость среза будут равны длине массива, и он будет использовать `a` в качестве своего базового массива."
  },
  {
    "id": 42,
    "topic": "Arrays and Slices",
    "question_text": "Что выведет следующий код: `s := make([]int, 3, 5); s = append(s, 1, 2); fmt.Println(len(s), cap(s))`?",
    "options": [
      "5 5",
      "5 10",
      "2 5",
      "3 5"
    ],
    "correct_options": [0],
    "explanation": "Изначально `len=3`, `cap=5`. `append(s, 1, 2)` добавляет два элемента. Новая длина становится `3+2=5`. Емкости (5) хватает, поэтому реалокации не происходит. Новая емкость остается 5."
  },
  {
    "id": 43,
    "topic": "Strings and Runes",
    "question_text": "Что из этого является верным утверждением о заголовке строки (`string header`)?",
    "options": [
      "Он не содержит поля `cap` (емкость).",
      "Он занимает 24 байта на 64-битной архитектуре.",
      "Он содержит срез байтов.",
      "Он является изменяемым."
    ],
    "correct_options": [0],
    "explanation": "В отличие от заголовка среза, заголовок строки состоит только из двух полей: указателя на данные и длины. Поле емкости отсутствует. Его размер на x64 — 16 байт."
  },
  {
    "id": 44,
    "topic": "Maps",
    "question_text": "Как проверить, существует ли ключ в карте?",
    "options": [
      "Использовать форму с двумя возвращаемыми значениями: `val, ok := m[key]`.",
      "Сравнить значение с `nil`: `m[key] == nil`.",
      "Использовать встроенную функцию `exists(m, key)`.",
      "Проитерироваться по всем ключам и сравнить."
    ],
    "correct_options": [0],
    "explanation": "Идиоматичный способ проверки наличия ключа — это `val, ok := m[key]`. Если ключ существует, `ok` будет `true`. Это позволяет отличить отсутствующий ключ от ключа, значение которого равно нулевому значению типа (например, 0 или \"\")."
  },
  {
    "id": 45,
    "topic": "Interfaces",
    "question_text": "Что представляет собой поле `data` в структуре `iface` или `eface`?",
    "options": [
      "Указатель на копию значения (для value-типов) или на само значение (для pointer-типов).",
      "Непосредственно само значение, если оно помещается в одно машинное слово.",
      "Указатель на `itab`.",
      "Метаданные о типе."
    ],
    "correct_options": [0],
    "explanation": "Поле `data` хранит указатель на данные. Если в интерфейс помещается value-тип (например, структура), то создается его копия в куче, и `data` указывает на нее. Если помещается указатель, то `data` хранит этот же указатель."
  },
  {
    "id": 46,
    "topic": "Memory Management",
    "question_text": "Что из перечисленного хранится на стеке горутины?",
    "options": [
      "Локальные переменные, чей жизненный цикл не выходит за пределы функции.",
      "Все переменные, объявленные внутри функции.",
      "Данные, отправленные в каналы.",
      "Базовые массивы для всех срезов."
    ],
    "correct_options": [0],
    "explanation": "На стеке хранятся данные, которые не 'уходят' в кучу, то есть те, на которые не будет ссылок после завершения функции. Это в основном локальные переменные простых типов или структур, которые не возвращаются по указателю."
  },
  {
    "id": 47,
    "topic": "Concurrency",
    "question_text": "Что такое `deadlock` (взаимоблокировка) в контексте каналов?",
    "options": [
      "Ситуация, когда все горутины в программе заблокированы и не могут продолжить выполнение.",
      "Когда горутина пытается записать в закрытый канал.",
      "Когда две горутины пытаются получить доступ к одной переменной.",
      "Когда канал переполнен."
    ],
    "correct_options": [0],
    "explanation": "Взаимоблокировка происходит, когда программа входит в состояние, где ни одна горутина не может двигаться дальше. Классический пример: главная горутина пытается прочитать из небуферизованного канала, но ни одна другая горутина не пишет в него. Рантайм обнаруживает такие ситуации и паникует."
  },
  {
    "id": 48,
    "topic": "Concurrency",
    "question_text": "Для чего используется `sync.WaitGroup`?",
    "options": [
      "Для ожидания завершения группы горутин.",
      "Для защиты общих данных от состояния гонки.",
      "Для выполнения какой-либо операции только один раз.",
      "Для создания пула горутин."
    ],
    "correct_options": [0],
    "explanation": "`WaitGroup` — это счетчик. Основная горутина вызывает `Add` для указания количества дочерних горутин, каждая из которых вызывает `Done` при завершении. Основная горутина вызывает `Wait`, который блокируется, пока счетчик не станет равен нулю."
  },
  {
    "id": 49,
    "topic": "System Design",
    "question_text": "Какое ключевое преимущество дал HTTP/2 по сравнению с HTTP/1.1?",
    "options": [
      "Мультиплексирование, позволяющее обрабатывать множество запросов в одном соединении одновременно.",
      "Шифрование по умолчанию.",
      "Использование текстового формата для простоты отладки.",
      "Работа поверх UDP."
    ],
    "correct_options": [0],
    "explanation": "Главным нововведением HTTP/2 стало мультиплексирование. Оно позволяет смешивать кадры от разных запросов и ответов в одном TCP-соединении, что решает проблему 'Head-of-Line blocking' на уровне приложения и значительно повышает производительность."
  },
  {
    "id": 50,
    "topic": "System Design",
    "question_text": "В чем основная идея 'Чистой архитектуры' (Clean Architecture)?",
    "options": [
      "Независимость бизнес-логики от внешних факторов, таких как фреймворки и базы данных.",
      "Использование микросервисов для каждого компонента системы.",
      "Написание всего кода в одном большом пакете для простоты.",
      "Применение строгого TDD (Test-Driven Development) ко всем компонентам."
    ],
    "correct_options": [0],
    "explanation": "Центральная идея 'Чистой архитектуры' — это правило зависимостей, направленное внутрь. Ядро системы (сущности и бизнес-логика) не должно ничего знать о внешних слоях (веб-сервер, БД). Это достигается за счет абстракций (интерфейсов)."
  },
  {
    "id": 51,
    "topic": "Arrays and Slices",
    "question_text": "Что выведет следующий код: `arr := [4]int{10, 20, 30, 40}; s := arr[1:3]; s[0] = 99; fmt.Println(arr)`?",
    "options": [
      "[10 99 30 40]",
      "[10 20 30 40]",
      "Произойдет паника 'index out of range'.",
      "Код не скомпилируется."
    ],
    "correct_options": [0],
    "explanation": "Срез `s` является 'видом' на базовый массив `arr`. Изменение элемента `s[0]` (который соответствует `arr[1]`) напрямую изменяет данные в исходном массиве `arr`."
  },
  {
    "id": 52,
    "topic": "Arrays and Slices",
    "question_text": "Как можно 'сбросить' срез `s`, чтобы его длина стала 0, но емкость и базовый массив сохранились?",
    "options": [
      "`s = s[:0]`",
      "`s = nil`",
      "`s = make([]int, 0)`",
      "Это невозможно сделать."
    ],
    "correct_options": [0],
    "explanation": "Операция `s = s[:0]` создает новый заголовок среза, у которого длина равна 0, но указатель и емкость остаются прежними, что позволяет переиспользовать уже выделенную память."
  },
  {
    "id": 53,
    "topic": "Arrays and Slices",
    "question_text": "Можно ли сравнить два массива `a := [2]int{1,2}` и `b := [2]int32{1,2}` с помощью `==`?",
    "options": [
      "Нет, потому что они имеют разный тип.",
      "Да, потому что у них одинаковая длина и значения.",
      "Да, но результат всегда будет `false`.",
      "Да, если привести `b` к типу `[2]int`."
    ],
    "correct_options": [0],
    "explanation": "Длина и тип элементов являются частью типа массива. `[2]int` и `[2]int32` — это два совершенно разных, несовместимых типа, поэтому их нельзя сравнивать напрямую."
  },
  {
    "id": 54,
    "topic": "Arrays and Slices",
    "question_text": "Согласно стратегии роста срезов в Go 1.18+, если у среза была емкость 300, и она была исчерпана, какой примерно будет новая емкость?",
    "options": [
      "Примерно 375 (рост ~25%).",
      "600 (удвоение).",
      "301.",
      "512 (ближайшая степень двойки)."
    ],
    "correct_options": [0],
    "explanation": "Для срезов размером более 256 элементов стратегия роста становится более консервативной, чем удвоение. Рост составляет примерно 25% (по специальной формуле), чтобы избежать чрезмерного расхода памяти."
  },
  {
    "id": 55,
    "topic": "Strings and Runes",
    "question_text": "Какой тип имеет переменная `r` в цикле `for _, r := range \"hello\"`?",
    "options": [
      "`rune` (он же `int32`)",
      "`string`",
      "`byte` (он же `uint8`)",
      "`interface{}`"
    ],
    "correct_options": [0],
    "explanation": "Цикл `for ... range` по строке декодирует UTF-8 символы. Второе возвращаемое значение — это всегда `rune` (кодовая точка Unicode), представляющая один символ."
  },
  {
    "id": 56,
    "topic": "Strings and Runes",
    "question_text": "Почему прямое изменение символа в строке, например `s[0] = 'a'`, невозможно в Go?",
    "options": [
      "Потому что строки в Go неизменяемы (immutable).",
      "Потому что `s[0]` возвращает `byte`, а не `rune`.",
      "Потому что для этого нужно использовать специальные функции.",
      "Это возможно, но только для ASCII-строк."
    ],
    "correct_options": [0],
    "explanation": "Ключевое свойство строк в Go — их неизменяемость. Любая 'модификация' строки, такая как конкатенация или замена, на самом деле создает в памяти новую строку."
  },
  {
    "id": 57,
    "topic": "Strings and Runes",
    "question_text": "Каковы потенциальные недостатки частого преобразования большой строки в `[]rune`?",
    "options": [
      "Высокие затраты на аллокацию памяти и процессорное время для декодирования.",
      "Возможность повредить исходную строку.",
      "Утечки памяти.",
      "Никаких недостатков, это стандартная практика."
    ],
    "correct_options": [0],
    "explanation": "Операция `[]rune(s)` каждый раз создает новый массив в куче и проходит по всей строке, декодируя символы. Для больших строк и в циклах это может стать узким местом производительности из-за аллокаций и нагрузки на ЦП."
  },
  {
    "id": 58,
    "topic": "Maps",
    "question_text": "Что вернет чтение из карты по несуществующему ключу `val := m[\"non-existent\"]`?",
    "options": [
      "Нулевое значение для типа значений карты (например, 0, \"\", nil).",
      "Произойдет паника.",
      "Вернется ошибка.",
      "Вернется специальное значение `undefined`."
    ],
    "correct_options": [0],
    "explanation": "Чтение из карты по несуществующему ключу является безопасной операцией. Оно всегда возвращает нулевое значение для типа-значения карты. Чтобы отличить этот случай от реально сохраненного нулевого значения, используется форма `val, ok := m[key]`."
  },
  {
    "id": 59,
    "topic": "Maps",
    "question_text": "Каково нулевое значение для типа `map[string]int`?",
    "options": [
      "`nil`",
      "Пустая карта `map[]{}`.",
      "0.",
      "У карт нет нулевого значения."
    ],
    "correct_options": [0],
    "explanation": "Переменная типа `map`, которая была объявлена, но не инициализирована (через `make` или литерал), имеет значение `nil`. В `nil`-карту нельзя записывать элементы (это вызовет панику), но из нее можно читать."
  },
  {
    "id": 60,
    "topic": "Maps",
    "question_text": "Каким образом рантайм Go обеспечивает случайный порядок итерации по карте?",
    "options": [
      "Используя случайное начальное значение (seed) для хеш-функции при создании карты.",
      "Выбирая случайный бакет для начала итерации.",
      "Перемешивая ключи перед каждой итерацией.",
      "Используя системное время как индекс."
    ],
    "correct_options": [0],
    "explanation": "При создании каждой новой карты рантайм инициализирует ее поле `hash0` случайным значением. Это приводит к тому, что хеши ключей и, соответственно, их распределение по бакетам, различаются от запуска к запуску, что и вызывает случайный порядок обхода."
  },
  {
    "id": 61,
    "topic": "Interfaces",
    "question_text": "Что такое 'type switch' в Go?",
    "options": [
      "Конструкция `switch v := i.(type)` для определения конкретного типа, хранящегося в интерфейсе.",
      "Способ преобразования одного типа в другой.",
      "Функция для переключения контекста горутины.",
      "Оператор для сравнения двух интерфейсов."
    ],
    "correct_options": [0],
    "explanation": "`type switch` — это идиоматичный и удобный способ выполнить различные действия в зависимости от динамического типа значения, хранящегося в интерфейсной переменной."
  },
  {
    "id": 62,
    "topic": "Interfaces",
    "question_text": "В каком случае вызов метода через интерфейсную переменную может вызвать панику `nil pointer dereference`?",
    "options": [
      "Когда интерфейсная переменная не равна `nil`, но содержит `nil`-указатель на конкретный тип.",
      "Когда сама интерфейсная переменная равна `nil`.",
      "В любом случае, если метод имеет указатель-приемник.",
      "Это невозможно."
    ],
    "correct_options": [0],
    "explanation": "Интерфейс равен `nil` только если и его тип, и значение равны `nil`. Если вы присвоите интерфейсу `nil`-указатель, сам интерфейс не будет `nil` (у него будет тип), но при вызове метода произойдет попытка разыменования `nil`-указателя `data`, что вызовет панику."
  },
  {
    "id": 63,
    "topic": "Interfaces",
    "question_text": "Может ли тип `T` удовлетворять интерфейсу, если его методы реализованы с указателем-приемником `(*T)`?",
    "options": [
      "Да, но только переменная типа `*T` будет удовлетворять интерфейсу.",
      "Да, и переменные типа `T` и `*T` будут удовлетворять интерфейсу.",
      "Нет, приемник должен быть того же типа.",
      "Только если `T` является структурой."
    ],
    "correct_options": [0],
    "explanation": "Если метод реализован для `*T`, то он принадлежит только типу-указателю `*T`. Тип-значение `T` этого метода не имеет. Go может автоматически взять адрес `T` (`&T`), если это возможно, но формально интерфейсу удовлетворяет только `*T`."
  },
  {
    "id": 64,
    "topic": "Memory Management",
    "question_text": "Каковы две основные фазы работы сборщика мусора 'mark-and-sweep'?",
    "options": [
      "Фаза пометки (Marking) и фаза очистки (Sweeping).",
      "Фаза аллокации (Allocating) и фаза освобождения (Freeing).",
      "Фаза остановки (Stopping) и фаза возобновления (Resuming).",
      "Фаза подсчета (Counting) и фаза обнуления (Zeroing)."
    ],
    "correct_options": [0],
    "explanation": "Алгоритм так и называется: 'пометка и очистка'. На фазе пометки GC находит все живые (достижимые) объекты. На фазе очистки он проходит по куче и освобождает память, занятую всеми недостижимыми (мусорными) объектами."
  },
  {
    "id": 65,
    "topic": "Memory Management",
    "question_text": "Как программист может повлиять на частоту запуска сборщика мусора?",
    "options": [
      "Изменяя переменную окружения `GOGC`.",
      "Вызывая `runtime.GC()` вручную.",
      "Используя ключевое слово `gc:off`.",
      "Никак, это полностью автоматический процесс."
    ],
    "correct_options": [0],
    "explanation": "Переменная `GOGC` (по умолчанию 100) задает соотношение. GC запускается, когда объем новой выделенной памяти достигает `GOGC` процентов от объема живой памяти после предыдущей сборки. Увеличение `GOGC` делает GC реже, но ценой большего расхода памяти."
  },
  {
    "id": 66,
    "topic": "Memory Management",
    "question_text": "Что такое пауза 'Stop-The-World' (STW) в контексте GC?",
    "options": [
      "Короткий период времени, когда выполнение всех горутин в программе полностью останавливается.",
      "Процесс остановки виртуальной машины Go.",
      "Ошибка, приводящая к зависанию программы.",
      "Пауза для записи логов работы GC."
    ],
    "correct_options": [0],
    "explanation": "STW — это пауза, во время которой GC должен выполнить операции, несовместимые с одновременным изменением состояния программы. Современный GC в Go спроектирован так, чтобы минимизировать длительность этих пауз, делая их почти незаметными."
  },
  {
    "id": 67,
    "topic": "Concurrency",
    "question_text": "Что произойдет при попытке отправить данные в закрытый канал?",
    "options": [
      "Произойдет паника.",
      "Операция завершится без ошибок, но данные будут потеряны.",
      "Горутина заблокируется.",
      "Канал автоматически откроется заново."
    ],
    "correct_options": [0],
    "explanation": "Спецификация Go четко определяет: отправка в закрытый канал — это ошибка программиста, которая приводит к панике во время выполнения. Читать из закрытого канала можно, отправлять — нельзя."
  },
  {
    "id": 68,
    "topic": "Concurrency",
    "question_text": "Что делает `default` в операторе `select`?",
    "options": [
      "Делает `select` неблокирующим: если ни один из каналов не готов, выполняется `default`.",
      "Выполняется, если все каналы в `case` закрыты.",
      "Задает канал, который будет выбран по умолчанию, если готовы несколько.",
      "Является синтаксической ошибкой."
    ],
    "correct_options": [0],
    "explanation": "Наличие `default` превращает блокирующий `select` в неблокирующий. Он позволяет проверить состояние нескольких каналов и немедленно продолжить выполнение, если ни одна операция не может быть выполнена прямо сейчас."
  },
  {
    "id": 69,
    "topic": "Concurrency",
    "question_text": "В чем основное отличие `sync.RWMutex` от `sync.Mutex`?",
    "options": [
      "`RWMutex` позволяет одновременный доступ для множества читателей или одного писателя.",
      "`RWMutex` работает быстрее в любых условиях.",
      "`Mutex` защищает только от записи, а `RWMutex` — от чтения и записи.",
      "Никаких, `RWMutex` — это просто псевдоним."
    ],
    "correct_options": [0],
    "explanation": "`RWMutex` (Read-Write Mutex) — это более гранулярная блокировка. Она различает операции чтения и записи. Множество горутин могут одновременно получить блокировку на чтение (`RLock`), но блокировка на запись (`Lock`) является эксклюзивной."
  },
  {
    "id": 70,
    "topic": "Concurrency",
    "question_text": "Для какой задачи идеально подходит `sync.Once`?",
    "options": [
      "Для инициализации синглтона или глобального ресурса, которая должна произойти ровно один раз.",
      "Для ожидания завершения группы горутин.",
      "Для атомарного инкремента счетчика.",
      "Для защиты критической секции кода."
    ],
    "correct_options": [0],
    "explanation": "`sync.Once` гарантирует, что переданная ему функция будет выполнена только один раз, независимо от того, сколько горутин одновременно попытаются это сделать. Это идеальный инструмент для ленивой и потокобезопасной инициализации."
  },
  {
    "id": 71,
    "topic": "System Design",
    "question_text": "Почему QUIC (основа HTTP/3) использует UDP, а не TCP?",
    "options": [
      "Чтобы избежать проблемы 'Head-of-Line blocking' на уровне транспортного протокола.",
      "Потому что UDP быстрее устанавливает соединение.",
      "Потому что UDP гарантирует доставку пакетов.",
      "Оба ответа про HOL blocking и скорость установки соединения верны."
    ],
    "correct_options": [3],
    "explanation": "QUIC реализует свои собственные механизмы надежности, потоков и контроля перегрузки поверх 'ненадежного' UDP. Это позволяет ему избежать HOL blocking (потеря пакета в одном потоке не влияет на другие) и быстрее устанавливать соединения (0-RTT)."
  },
  {
    "id": 72,
    "topic": "System Design",
    "question_text": "Что такое идемпотентность (idempotency) операции в REST API?",
    "options": [
      "Повторное выполнение операции приводит к тому же результату, что и однократное.",
      "Операция не изменяет состояние системы.",
      "Операция всегда выполняется успешно.",
      "Операция выполняется атомарно."
    ],
    "correct_options": [0],
    "explanation": "Идемпотентная операция — это операция, многократное применение которой дает тот же эффект, что и однократное. Например, `PUT /users/1` или `DELETE /users/1` идемпотентны, а `POST /users` — нет."
  },
  {
    "id": 73,
    "topic": "System Design",
    "question_text": "Какова основная роль Protocol Buffers в gRPC?",
    "options": [
      "Служить языком описания интерфейсов (IDL) и форматом сериализации данных.",
      "Определять правила маршрутизации запросов.",
      "Обеспечивать шифрование.",
      "Управлять жизненным циклом соединения."
    ],
    "correct_options": [0],
    "explanation": "Protobuf используется для определения 'контракта' между клиентом и сервером в `.proto` файлах (какие есть сервисы, методы, сообщения). Он также является бинарным форматом, в который эти сообщения кодируются для передачи по сети, что эффективнее JSON/XML."
  },
  {
    "id": 74,
    "topic": "System Design",
    "question_text": "Что такое 'компенсирующая транзакция' в паттерне Saga?",
    "options": [
      "Операция, которая отменяет действие предыдущей успешной транзакции в случае сбоя на последующем шаге.",
      "Повторная попытка выполнить сбойную транзакцию.",
      "Транзакция, которая записывает информацию об ошибке в лог.",
      "Альтернативная транзакция, выполняемая в случае сбоя основной."
    ],
    "correct_options": [0],
    "explanation": "Поскольку в распределенной системе нет единой атомарной транзакции, Saga обеспечивает согласованность через последовательность локальных транзакций. Если что-то идет не так, для каждого уже выполненного шага вызывается его 'антидот' — компенсирующая транзакция, чтобы вернуть систему в согласованное состояние."
  },
  {
    "id": 75,
    "topic": "System Design",
    "question_text": "Принцип инверсии зависимостей (Dependency Inversion) из SOLID гласит, что...",
    "options": [
      "Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба должны зависеть от абстракций.",
      "Модули нижних уровней должны зависеть от модулей верхних уровней.",
      "Все зависимости в проекте должны быть инвертированы.",
      "Следует предпочитать конкретные реализации абстракциям."
    ],
    "correct_options": [0],
    "explanation": "Этот принцип лежит в основе 'Чистой архитектуры'. Вместо того чтобы бизнес-логика напрямую зависела от конкретной реализации базы данных, она зависит от интерфейса (например, `UserRepository`). А уже конкретная реализация для PostgreSQL 'зависит' от этого интерфейса, реализуя его."
  },
  {
    "id": 76,
    "topic": "Arrays and Slices",
    "question_text": "Код `s1 := []int{1, 2}; s2 := append(s1, 3)`. Если после этого выполнить `s2[0] = 99`, изменится ли `s1`?",
    "options": [
      "Зависит от начальной емкости `s1`.",
      "Да, всегда.",
      "Нет, никогда.",
      "Это приведет к ошибке компиляции."
    ],
    "correct_options": [0],
    "explanation": "Если при создании `s1` компилятор выделил массив с емкостью больше 2, то `append` не будет создавать новый массив, и `s1` и `s2` будут разделять общую память. Если же емкость была ровно 2, то `append` создаст новый массив, и `s1` не изменится. Поведение зависит от аллокации."
  },
  {
    "id": 77,
    "topic": "Arrays and Slices",
    "question_text": "Как создать срез `[]int` с длиной 0 и емкостью 100?",
    "options": [
      "`make([]int, 0, 100)`",
      "`make([]int, 100)`",
      "`make([]int, 100, 0)`",
      "Это невозможно."
    ],
    "correct_options": [0],
    "explanation": "Функция `make` для срезов принимает три аргумента: тип, длину и опционально емкость. `make([]int, 0, 100)` создает срез с `len=0` и `cap=100`, что является эффективным способом предварительно выделить память."
  },
  {
    "id": 78,
    "topic": "Strings and Runes",
    "question_text": "Каков результат выражения `string(97)` в Go?",
    "options": [
      "\"a\"",
      "\"97\"",
      "Ошибка компиляции.",
      "Паника во время выполнения."
    ],
    "correct_options": [0],
    "explanation": "Преобразование целого числа в `string` интерпретирует это число как кодовую точку Unicode (руну). Кодовая точка 97 соответствует латинской букве 'a'."
  },
  {
    "id": 79,
    "topic": "Maps",
    "question_text": "Что произойдет при попытке записи в `nil`-карту?",
    "options": [
      "Паника во время выполнения.",
      "Операция будет проигнорирована.",
      "Карта будет автоматически инициализирована.",
      "Ошибка компиляции."
    ],
    "correct_options": [0],
    "explanation": "В `nil`-карту (например, `var m map[int]int`) нельзя записывать значения. Попытка сделать это (`m[1] = 1`) приведет к панике. Перед записью карту необходимо инициализировать с помощью `make` или литерала."
  },
  {
    "id": 80,
    "topic": "Maps",
    "question_text": "Можно ли использовать срез (`[]int`) в качестве ключа в карте?",
    "options": [
      "Нет, потому что срезы не являются сравнимым типом.",
      "Да, без ограничений.",
      "Да, если срез содержит только сравнимые элементы.",
      "Только если срез пустой."
    ],
    "correct_options": [0],
    "explanation": "Ключи в карте должны быть сравнимыми типами (поддерживать операторы `==` и `!=`). Срезы, карты и функции не являются сравнимыми, поэтому их нельзя использовать в качестве ключей."
  },
  {
    "id": 81,
    "topic": "Interfaces",
    "question_text": "Может ли интерфейс в Go встраивать (embed) другие интерфейсы?",
    "options": [
      "Да, это способ композиции интерфейсов.",
      "Нет, интерфейсы не могут быть встроены.",
      "Только если встраиваемый интерфейс пустой.",
      "Только один интерфейс может быть встроен."
    ],
    "correct_options": [0],
    "explanation": "Да, один интерфейс может встраивать другие. Это объединяет наборы методов. Тип, реализующий такой композитный интерфейс, должен реализовать все методы из всех встроенных интерфейсов. Пример: `io.ReadWriter` встраивает `io.Reader` и `io.Writer`."
  },
  {
    "id": 82,
    "topic": "Memory Management",
    "question_text": "Какая из этих операций, скорее всего, НЕ приведет к аллокации памяти в куче?",
    "options": [
      "Суммирование двух локальных переменных `int`.",
      "Создание среза с переменной длиной `make([]byte, n)`.",
      "Конкатенация двух строк.",
      "Присвоение структуры переменной типа `any`."
    ],
    "correct_options": [0],
    "explanation": "Арифметические операции над локальными переменными базовых типов почти всегда происходят на стеке (или даже в регистрах). Остальные операции (создание среза с неизвестным размером, создание новой строки, упаковка значения в интерфейс) обычно требуют аллокации в куче."
  },
  {
    "id": 83,
    "topic": "Concurrency",
    "question_text": "Что такое `context.Context` в Go и какова его основная цель?",
    "options": [
      "Передача сигналов отмены, дедлайнов и значений по цепочке вызовов, особенно в конкурентной среде.",
      "Хранение глобального состояния приложения.",
      "Управление пулом горутин.",
      "Представление контекста выполнения операционной системы."
    ],
    "correct_options": [0],
    "explanation": "`Context` является стандартным способом управлять отменой операций (например, из-за таймаута или запроса пользователя), а также передавать метаданные (например, ID запроса) через границы API без явной передачи их в каждом аргументе функции."
  },
  {
    "id": 84,
    "topic": "Concurrency",
    "question_text": "Что произойдет, если родительский `context` будет отменен?",
    "options": [
      "Все дочерние контексты, созданные от него, также будут отменены.",
      "Ничего не произойдет с дочерними контекстами.",
      "Только один случайный дочерний контекст будет отменен.",
      "Произойдет паника."
    ],
    "correct_options": [0],
    "explanation": "Контексты образуют дерево. Отмена родительского контекста каскадно распространяется на всех его потомков. Это позволяет легко отменить целое дерево операций (например, все обработчики, связанные с одним входящим HTTP-запросом)."
  },
  {
    "id": 85,
    "topic": "Concurrency",
    "question_text": "Что делает `atomic.CompareAndSwap` (CAS)?",
    "options": [
      "Атомарно обновляет значение, только если его текущее значение равно ожидаемому.",
      "Сравнивает два атомарных значения.",
      "Меняет местами два значения в памяти.",
      "Атомарно добавляет значение к переменной."
    ],
    "correct_options": [0],
    "explanation": "Compare-And-Swap — это мощная низкоуровневая операция. Она говорит: 'посмотри на адрес X, если там лежит значение Y, то запиши туда Z, и скажи мне, получилось ли'. Это основа для реализации многих lock-free алгоритмов."
  },
  {
    "id": 86,
    "topic": "System Design",
    "question_text": "Выберите верные утверждения о gRPC. (несколько вариантов)",
    "options": [
      "Использует HTTP/2 в качестве транспорта.",
      "По умолчанию использует Protocol Buffers для сериализации.",
      "Поддерживает потоковую передачу данных (streaming).",
      "Использует JSON в качестве основного формата сообщений."
    ],
    "correct_options": [0, 1, 2],
    "explanation": "gRPC — это современный RPC-фреймворк, построенный на HTTP/2, использующий Protocol Buffers как эффективный бинарный формат и IDL, и имеющий встроенную поддержку различных видов стриминга."
  },
  {
    "id": 87,
    "topic": "Arrays and Slices",
    "question_text": "В чем разница между `var s []int` и `s := make([]int, 0)`?",
    "options": [
      "В первом случае `s` будет `nil`, во втором — это будет срез с `len=0`, `cap=0`, не равный `nil`.",
      "Никакой разницы, оба создают `nil`-срез.",
      "Первый вариант не скомпилируется.",
      "Во втором случае `s` будет иметь ненулевую емкость."
    ],
    "correct_options": [0],
    "explanation": "`var s []int` объявляет переменную `s` и оставляет ее с нулевым значением, которым для среза является `nil`. `make([]int, 0)` явно создает заголовок среза, который указывает на пустой базовый массив, поэтому он не `nil`."
  },
  {
    "id": 88,
    "topic": "Arrays and Slices",
    "question_text": "Можно ли создать массив, длина которого определяется переменной?",
    "options": [
      "Нет, длина массива должна быть константой времени компиляции.",
      "Да, `n := 10; var arr [n]int`.",
      "Да, но только если переменная является `const`.",
      "Только с помощью функции `make`."
    ],
    "correct_options": [0],
    "explanation": "Длина массива является частью его типа, и компилятор должен знать точный тип во время компиляции. Поэтому длина должна быть константой. Для динамической длины следует использовать срезы и `make`."
  },
  {
    "id": 89,
    "topic": "Strings and Runes",
    "question_text": "Что из этого является корректным способом получить i-тый СИМВОЛ строки?",
    "options": [
      "`rune_slice := []rune(s); char := rune_slice[i]`",
      "`char := s[i]`",
      "`char := range s[i]`",
      "`char := string(s[i])`"
    ],
    "correct_options": [0],
    "explanation": "Прямой доступ `s[i]` дает i-тый байт. Чтобы получить i-тый символ (руну) с произвольным доступом, необходимо сначала преобразовать строку в срез рун, что дает O(1) доступ к символам, но требует O(N) на само преобразование."
  },
  {
    "id": 90,
    "topic": "Maps",
    "question_text": "Что произойдет с памятью, занимаемой картой, после удаления из нее всех элементов с помощью `delete`?",
    "options": [
      "Память, выделенная под бакеты, не освобождается автоматически, но может быть переиспользована для новых элементов.",
      "Память немедленно возвращается операционной системе.",
      "Карта становится `nil`.",
      "Размер карты уменьшается вдвое."
    ],
    "correct_options": [0],
    "explanation": "Удаление элементов из карты не приводит к сжатию ее базового массива бакетов. Выделенная память остается за картой для будущего использования. Полное освобождение памяти произойдет только тогда, когда сама карта станет недоступной и будет собрана GC."
  },
  {
    "id": 91,
    "topic": "Interfaces",
    "question_text": "В чем преимущество использования маленьких, сфокусированных интерфейсов (как `io.Reader`) в Go?",
    "options": [
      "Их легче реализовать и они способствуют созданию гибких, композитных компонентов.",
      "Они работают быстрее, чем большие интерфейсы.",
      "Они занимают меньше памяти.",
      "Все перечисленное."
    ],
    "correct_options": [0],
    "explanation": "Маленькие интерфейсы (часто с одним методом) легко удовлетворить. Это позволяет разным типам реализовывать только те интерфейсы, которые им действительно нужны, и позволяет строить сложные системы, комбинируя простые компоненты. Это соответствует принципу разделения интерфейсов из SOLID."
  },
  {
    "id": 92,
    "topic": "Memory Management",
    "question_text": "Если функция принимает аргумент типа `interface{}`, что, скорее всего, произойдет со значением, которое в нее передали?",
    "options": [
      "Оно 'уйдет' в кучу, так как его жизненный цикл становится неизвестным.",
      "Оно всегда останется на стеке.",
      "Произойдет копирование значения без аллокации в куче.",
      "Это зависит от размера значения."
    ],
    "correct_options": [0],
    "explanation": "Когда значение упаковывается в интерфейс, компилятор не может статически доказать, что оно не 'переживет' вызов функции. Поэтому, чтобы быть в безопасности, он обычно размещает копию этого значения в куче. Это одна из частых причин скрытых аллокаций."
  },
  {
    "id": 93,
    "topic": "Concurrency",
    "question_text": "Можно ли безопасно передать указатель на данные через канал?",
    "options": [
      "Да, но нужно убедиться, что после отправки отправитель не изменяет данные, к которым имеет доступ получатель (во избежание data race).",
      "Нет, через каналы можно передавать только значения.",
      "Да, каналы автоматически копируют данные, на которые указывает указатель.",
      "Только если указатель указывает на данные на стеке."
    ],
    "correct_options": [0],
    "explanation": "Канал копирует значение, которое в него отправляют. Если это значение — указатель, то копируется сам указатель (адрес), а не данные за ним. Обе горутины будут иметь доступ к одной и той же области памяти, что требует осторожности и синхронизации, если данные изменяемы."
  },
  {
    "id": 94,
    "topic": "Concurrency",
    "question_text": "Что такое 'fan-out, fan-in' в контексте конвейеров на каналах?",
    "options": [
      "Паттерн, где одна горутина распределяет работу (fan-out) на несколько воркеров, а другая собирает результаты (fan-in).",
      "Способ увеличить буфер канала.",
      "Техника отладки каналов.",
      "Метод для закрытия группы каналов."
    ],
    "correct_options": [0],
    "explanation": "Это распространенный паттерн для параллельной обработки данных. 'Fan-out': один канал-источник читается несколькими горутинами-воркерами. 'Fan-in': результаты работы всех воркеров собираются (мультиплексируются) в один общий канал-приемник."
  },
  {
    "id": 95,
    "topic": "System Design",
    "question_text": "Какой уровень модели OSI отвечает за маршрутизацию пакетов между сетями?",
    "options": [
      "Сетевой (Network Layer).",
      "Транспортный (Transport Layer).",
      "Канальный (Data Link Layer).",
      "Физический (Physical Layer)."
    ],
    "correct_options": [0],
    "explanation": "Сетевой уровень (L3) отвечает за логическую адресацию (IP-адреса) и определение наилучшего пути для доставки пакетов от источника к получателю через одну или несколько сетей."
  },
  {
    "id": 96,
    "topic": "Arrays and Slices",
    "question_text": "Что выведет `fmt.Println([3]int{1,2,3} == [...]int{1,2,3})`?",
    "options": [
      "`true`",
      "`false`",
      "Ошибка компиляции.",
      "Зависит от архитектуры."
    ],
    "correct_options": [0],
    "explanation": "Конструкция `[...]int{...}` — это синтаксический сахар, который заставляет компилятора вычислить длину массива на основе количества элементов. В данном случае он создаст массив типа `[3]int`. Так как типы, длины и значения массивов идентичны, они равны."
  },
  {
    "id": 97,
    "topic": "Strings and Runes",
    "question_text": "Если передать строку в функцию, может ли эта функция изменить исходную строку?",
    "options": [
      "Нет, потому что строки в Go неизменяемы.",
      "Да, если функция принимает указатель `*string`.",
      "Да, если использовать пакет `unsafe`.",
      "Только если строка состоит из ASCII символов."
    ],
    "correct_options": [0],
    "explanation": "Фундаментальное свойство строк — их неизменяемость. Функция может получить указатель `*string` и присвоить ему новую строку, изменив таким образом переменную в вызывающей стороне, но она не может изменить байты исходной строки."
  },
  {
    "id": 98,
    "topic": "Interfaces",
    "question_text": "Что из этого НЕ является интерфейсом?",
    "options": [
      "`map[string]interface{}`",
      "`error`",
      "`io.Reader`",
      "`any`"
    ],
    "correct_options": [0],
    "explanation": "`map[string]interface{}` — это конкретный тип (карта), у которого тип значения — пустой интерфейс. `error`, `io.Reader` и `any` (псевдоним для `interface{}`) — это типы-интерфейсы."
  },
  {
    "id": 99,
    "topic": "Concurrency",
    "question_text": "В `select` есть два готовых к чтению канала. Какой из них будет выбран?",
    "options": [
      "Будет выбран один из них псевдослучайным образом.",
      "Тот, который объявлен в `case` раньше.",
      "Тот, в который данные были записаны раньше.",
      "Произойдет паника."
    ],
    "correct_options": [0],
    "explanation": "Если несколько `case` в `select` могут быть выполнены одновременно, рантайм выбирает один из них псевдослучайно. Это обеспечивает справедливость и предотвращает ситуацию, когда один канал постоянно 'голодает'."
  },
  {
    "id": 100,
    "topic": "Memory Management",
    "question_text": "Какова основная задача фонового процесса Sysmon в рантайме Go?",
    "options": [
      "Обнаружение горутин, застрявших в длительных системных вызовах, и инициирование 'handoff' для процессора P.",
      "Мониторинг использования CPU и памяти программой.",
      "Запуск сборщика мусора по расписанию.",
      "Проверка системы на наличие обновлений Go."
    ],
    "correct_options": [0],
    "explanation": "Sysmon выполняет несколько служебных задач, но одна из ключевых — это 'спасение' процессоров (P) от потоков (M), которые надолго заблокировались в syscall. Он отсоединяет P от заблокированного M и передает его новому или свободному M, чтобы работа не простаивала."
  },
  {
    "id": 101,
    "topic": "Arrays and Slices",
    "question_text": "Что произойдет, если выполнить `append` на срезе, у которого `len` меньше `cap`, и результат `append` не присвоить обратно переменной?",
    "options": [
      "Изменения будут видны в базовом массиве, но длина исходного среза не изменится.",
      "Ничего не изменится ни в срезе, ни в базовом массиве.",
      "Произойдет утечка памяти.",
      "Код не скомпилируется."
    ],
    "correct_options": [0],
    "explanation": "Если емкости хватает, `append` записывает данные в базовый массив. `append` возвращает новый заголовок среза с обновленной длиной. Если его не присвоить, исходная переменная среза сохранит свою старую, меньшую длину, хотя данные в базовом массиве за ее пределами уже изменены."
  },
  {
    "id": 102,
    "topic": "Arrays and Slices",
    "question_text": "Какая временная сложность у операции доступа к элементу массива или среза по индексу (например, `s[i]`)?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "Зависит от типа элементов."
    ],
    "correct_options": [0],
    "explanation": "И массивы, и срезы (через базовый массив) хранят данные в непрерывном блоке памяти. Адрес любого элемента можно вычислить математически за константное время, поэтому доступ по индексу имеет сложность O(1)."
  },
  {
    "id": 103,
    "topic": "Arrays and Slices",
    "question_text": "Как наиболее эффективно удалить элемент из среза `s` по индексу `i` без сохранения порядка?",
    "options": [
      "`s[i] = s[len(s)-1]; s = s[:len(s)-1]`",
      "`s = append(s[:i], s[i+1:]...)`",
      "Создать новый срез и скопировать туда все элементы, кроме `i`-го.",
      "Использовать `delete(s, i)`."
    ],
    "correct_options": [0],
    "explanation": "Этот метод самый быстрый, так как он избегает сдвига всех последующих элементов. Он просто заменяет удаляемый элемент последним и затем укорачивает срез. Это операция O(1). Метод с `append` сохраняет порядок, но имеет сложность O(n)."
  },
  {
    "id": 104,
    "topic": "Arrays and Slices",
    "question_text": "Структура `Padding { f1 bool; f2 int64; f3 bool }` занимает на x64 архитектуре 24 байта. Почему?",
    "options": [
      "Из-за выравнивания памяти (memory alignment).",
      "Потому что `bool` занимает 8 байт.",
      "Это ошибка, она должна занимать 10 байт (1+8+1).",
      "Из-за накладных расходов на хранение метаданных структуры."
    ],
    "correct_options": [0],
    "explanation": "Компилятор добавляет 'прокладки' (padding), чтобы поля были выровнены по адресам, кратным их размеру. Между `f1` и `f2` будет добавлено 7 байт, чтобы `int64` начался с адреса, кратного 8. После `f3` будет добавлено еще 7 байт, чтобы общий размер структуры был кратен 8."
  },
  {
    "id": 105,
    "topic": "Strings and Runes",
    "question_text": "Что выведет этот код: `s := \"кот\"; fmt.Println(string(s[0]), string(s[1]))`?",
    "options": [
      "Два символа-заменителя ``, так как `s[0]` и `s[1]` являются невалидными UTF-8 символами.",
      "`к о`",
      "`к` и затем панику.",
      "Код не скомпилируется."
    ],
    "correct_options": [0],
    "explanation": "Символ 'к' в UTF-8 кодируется двумя байтами. `s[0]` и `s[1]` — это эти два байта по отдельности. Каждый из них не является валидным символом, поэтому при преобразовании в строку и печати отображается символ-заменитель."
  },
  {
    "id": 106,
    "topic": "Strings and Runes",
    "question_text": "Выберите верные способы создать строку в Go. (несколько вариантов)",
    "options": [
      "Используя двойные кавычки: `s := \"hello\"`.",
      "Используя обратные кавычки (raw string literal): `s := \`hello\\nworld\``.",
      "Преобразуя срез байтов: `s := string([]byte{...})`.",
      "Используя одинарные кавычки: `s := 'hello'`."
    ],
    "correct_options": [0, 1, 2],
    "explanation": "Строки создаются с помощью двойных кавычек (с обработкой escape-последовательностей) или обратных кавычек (сырые строки, где все символы, включая перевод строки, сохраняются как есть). Также их можно создать из `[]byte` или `[]rune`. Одинарные кавычки используются для рун, а не строк."
  },
  {
    "id": 107,
    "topic": "Maps",
    "question_text": "Что такое 'инкрементальная эвакуация' при расширении карты?",
    "options": [
      "Процесс постепенного переноса данных из старых бакетов в новые, 'размазанный' по операциям записи/удаления.",
      "Немедленное копирование всех данных в новый, больший массив бакетов.",
      "Удаление старых данных из карты для освобождения места.",
      "Проверка целостности данных в карте."
    ],
    "correct_options": [0],
    "explanation": "Чтобы избежать длительных пауз 'Stop-The-World', современный рантайм Go не копирует все данные сразу. Он создает новый массив бакетов, и при каждой последующей мутирующей операции переносит 1-2 старых бакета, 'размазывая' работу по времени."
  },
  {
    "id": 108,
    "topic": "Maps",
    "question_text": "Как удалить ключ `key` из карты `m`?",
    "options": [
      "Используя встроенную функцию `delete(m, key)`.",
      "Присвоив `m[key] = nil`.",
      "Используя `m.delete(key)`.",
      "Это невозможно, можно только перезаписать значение."
    ],
    "correct_options": [0],
    "explanation": "`delete` — это встроенная функция, специально предназначенная для удаления пар ключ-значение из карты. Если ключ не существует, операция ничего не делает и не вызывает ошибок."
  },
  {
    "id": 109,
    "topic": "Interfaces",
    "question_text": "Что хранится в массиве `fun` структуры `itab`?",
    "options": [
      "Указатели на конкретные реализации методов, соответствующие порядку методов в интерфейсе.",
      "Хеши методов.",
      "Имена методов в виде строк.",
      "Указатели на типы аргументов методов."
    ],
    "correct_options": [0],
    "explanation": "Массив `fun` — это и есть 'виртуальная таблица' (v-table). Он содержит указатели на функции — конкретные реализации методов для данного типа, которые требуются интерфейсом. Это позволяет выполнять динамическую диспетчеризацию вызовов."
  },
  {
    "id": 110,
    "topic": "Interfaces",
    "question_text": "Если `var err error`, почему проверка `err != nil` может быть `true`, даже если внутри `err` лежит `nil`-указатель?",
    "options": [
      "Потому что интерфейс `err` не равен `nil`, если у него установлен динамический тип, даже если динамическое значение — `nil`.",
      "Это невозможно, если значение `nil`, то и интерфейс `nil`.",
      "Из-за ошибки в рантайме Go.",
      "Потому что `error` — это особый тип, который никогда не бывает `nil`."
    ],
    "correct_options": [0],
    "explanation": "Интерфейсная переменная равна `nil` только когда и ее тип (`_type` / `tab`), и ее значение (`data`) равны `nil`. Если функции, возвращающей `error`, присвоить `nil`-указатель конкретного типа (например, `(*CustomError)(nil)`), то у интерфейса `err` будет установлен тип `*CustomError`, а значением будет `nil`. Сам интерфейс при этом не `nil`."
  },
  {
    "id": 111,
    "topic": "Memory Management",
    "question_text": "Какая из этих структур, скорее всего, займет меньше памяти на x64 архитектуре?",
    "options": [
      "`struct { f1 bool; f2 bool; f3 int64 }`",
      "`struct { f1 bool; f2 int64; f3 bool }`",
      "`struct { f1 int64; f2 bool; f3 bool }`",
      "Они все займут одинаковый объем памяти."
    ],
    "correct_options": [0],
    "explanation": "Группировка полей по размеру (от меньшего к большему или наоборот) минимизирует 'прокладки' (padding). В варианте `bool, bool, int64` два `bool` занимают 2 байта, затем добавляется 6 байт padding, и затем 8 байт `int64`. Итого 16 байт. Вариант `bool, int64, bool` потребует 24 байта."
  },
  {
    "id": 112,
    "topic": "Memory Management",
    "question_text": "Что такое `mspan` (memory span) во внутреннем устройстве аллокатора памяти Go?",
    "options": [
      "Непрерывный участок памяти, состоящий из одной или нескольких страниц, управляющий блоками одного размера.",
      "Указатель на стек горутины.",
      "Кеш памяти для одного процессора (P).",
      "Глобальный список свободной памяти."
    ],
    "correct_options": [0],
    "explanation": "Куча в Go организована иерархически. `mspan` — это основной строительный блок. Он управляет группой страниц памяти и выделяет из них объекты определенного 'класса размера' (size class). `mspan`-ы перемещаются между `mcentral` и `mcache`."
  },
  {
    "id": 113,
    "topic": "Concurrency",
    "question_text": "Что такое 'состояние гонки' (data race)? Выберите наиболее точное определение.",
    "options": [
      "Ситуация, когда две или более горутины одновременно обращаются к одной и той же области памяти, и хотя бы одна из них выполняет запись.",
      "Ситуация, когда две горутины выполняются быстрее, чем ожидалось.",
      "Любой конкурентный доступ к общим данным.",
      "Взаимная блокировка (deadlock) двух горутин."
    ],
    "correct_options": [0],
    "explanation": "Определение состояния гонки очень специфично: 1) две или более горутины, 2) одновременный доступ, 3) одна и та же память, 4) хотя бы одна операция — запись. Все четыре условия должны быть выполнены."
  },
  {
    "id": 114,
    "topic": "Concurrency",
    "question_text": "Можно ли закрыть канал, в который все еще пишут данные?",
    "options": [
      "Да, но любая последующая попытка записи в него вызовет панику.",
      "Нет, это вызовет панику в момент закрытия.",
      "Да, но только если канал буферизованный.",
      "Нет, сначала нужно дождаться завершения всех операций записи."
    ],
    "correct_options": [0],
    "explanation": "Закрыть канал можно в любой момент. Операция `close` сама по себе безопасна. Однако горутины, которые после этого попытаются отправить данные в этот канал, запаникуют. Обычно канал закрывает отправитель, чтобы сигнализировать получателям, что данных больше не будет."
  },
  {
    "id": 115,
    "topic": "Concurrency",
    "question_text": "Что такое `context.WithValue` и когда его следует использовать?",
    "options": [
      "Для передачи метаданных, таких как ID запроса, через цепочку вызовов. Следует использовать с осторожностью.",
      "Для передачи обязательных аргументов в функции.",
      "Для создания контекста с таймаутом.",
      "Для отмены контекста."
    ],
    "correct_options": [0],
    "explanation": "`WithValue` предназначен для передачи опциональных, сквозных данных, которые не являются частью бизнес-логики (ID трассировки, данные аутентификации). Его не следует использовать для передачи обычных аргументов, так как это делает API неявным и менее безопасным."
  },
  {
    "id": 116,
    "topic": "System Design",
    "question_text": "Какой из методов HTTP является идемпотентным, но не безопасным?",
    "options": [
      "`PUT`",
      "`GET`",
      "`POST`",
      "`HEAD`"
    ],
    "correct_options": [0],
    "explanation": "`PUT` не является безопасным, так как он изменяет состояние ресурса. Однако он идемпотентен: повторный `PUT` с теми же данными приведет к тому же состоянию ресурса, что и первый. `GET` и `HEAD` безопасны. `POST` не является ни безопасным, ни идемпотентным."
  },
  {
    "id": 117,
    "topic": "System Design",
    "question_text": "В 'Чистой архитектуре', где должны находиться интерфейсы, определяющие контракты для работы с базой данных (например, `UserRepository`)?",
    "options": [
      "В слое Use Cases (сценариев использования).",
      "В слое Entities (сущностей).",
      "В слое Frameworks & Drivers (внешнем слое).",
      "В слое Interface Adapters (адаптеров)."
    ],
    "correct_options": [0],
    "explanation": "Согласно принципу инверсии зависимостей, внутренний слой (Use Cases) определяет, какие ему нужны 'порты' (интерфейсы) для взаимодействия с внешним миром. А внешний слой (Frameworks) предоставляет 'адаптеры' (конкретные реализации этих интерфейсов)."
  },
  {
    "id": 118,
    "topic": "Arrays and Slices",
    "question_text": "Что выведет код `var a [2][3]int; fmt.Print(len(a), len(a[0]))`?",
    "options": [
      "2 3",
      "2 0",
      "0 0",
      "Ошибка компиляции."
    ],
    "correct_options": [0],
    "explanation": "`a` — это массив из 2 элементов, где каждый элемент — это массив из 3 `int`. `len(a)` возвращает длину внешнего массива (2). `a[0]` — это первый элемент, который является массивом `[3]int`, поэтому `len(a[0])` возвращает 3."
  },
  {
    "id": 119,
    "topic": "Strings and Runes",
    "question_text": "Что такое `UTF-8`?",
    "options": [
      "Кодировка символов переменной длины, используемая в Go по умолчанию для строк.",
      "Кодировка символов фиксированной длины (4 байта).",
      "Набор символов, включающий только латиницу.",
      "Алгоритм сжатия строк."
    ],
    "correct_options": [0],
    "explanation": "UTF-8 — это стандарт кодирования, который может представлять любую кодовую точку Unicode, используя от 1 до 4 байт. Он обратно совместим с ASCII (ASCII-символы кодируются одним байтом), что является одним из его преимуществ."
  },
  {
    "id": 120,
    "topic": "Maps",
    "question_text": "Можно ли получить адрес элемента в карте, например `&m[key]`?",
    "options": [
      "Нет, элементы в карте не являются адресуемыми.",
      "Да, без ограничений.",
      "Да, но только если значение является структурой.",
      "Только с использованием пакета `unsafe`."
    ],
    "correct_options": [0],
    "explanation": "Компилятор Go запрещает брать адрес элемента карты. Причина в том, что при расширении карты все элементы могут быть перемещены в памяти на новые места. Если бы можно было сохранять указатели на них, эти указатели стали бы невалидными, что привело бы к ошибкам."
  },
  {
    "id": 121,
    "topic": "Interfaces",
    "question_text": "Что произойдет, если в `type switch` ни один из `case` не совпадет с типом в интерфейсе?",
    "options": [
      "Будет выполнен блок `default`, если он есть.",
      "Произойдет паника.",
      "Будет возвращена ошибка.",
      "Цикл `switch` будет пропущен без выполнения какого-либо блока."
    ],
    "correct_options": [0],
    "explanation": "`type switch` ведет себя как обычный `switch`. Если ни один из `case` не соответствует, и есть блок `default`, то управление передается ему. Если `default` нет, то `switch` просто завершается."
  },
  {
    "id": 122,
    "topic": "Memory Management",
    "question_text": "Что произойдет со стеком горутины, если она вызовет рекурсивную функцию, которая приведет к очень глубокой рекурсии?",
    "options": [
      "Стек будет динамически расти до определенного предела, после чего произойдет паника `stack overflow`.",
      "Стек будет автоматически перемещен в кучу.",
      "Рантайм автоматически прервет рекурсию.",
      "Произойдет утечка памяти."
    ],
    "correct_options": [0],
    "explanation": "Стеки горутин растут по мере необходимости, но они не бесконечны. При каждом вызове функции на стек помещается новый кадр. Если глубина рекурсии превысит максимальный размер стека (например, 1 ГБ на x64), произойдет паника."
  },
  {
    "id": 123,
    "topic": "Concurrency",
    "question_text": "Что такое `select{}` (пустой select)?",
    "options": [
      "Операция, которая блокирует горутину навсегда.",
      "Синтаксическая ошибка.",
      "Неблокирующая операция, которая ничего не делает.",
      "Способ дождаться закрытия всех каналов."
    ],
    "correct_options": [0],
    "explanation": "Пустой `select` без `case` и `default` не имеет ни одного условия для выхода из блокировки. Поэтому горутина, которая его выполняет, будет заблокирована навсегда. Это иногда используется для блокировки главной горутины в конце программы."
  },
  {
    "id": 124,
    "topic": "Concurrency",
    "question_text": "Какой из примитивов синхронизации является самым быстрым для простого инкремента счетчика?",
    "options": [
      "Пакет `atomic`, например `atomic.AddInt64`.",
      "`sync.Mutex`.",
      "Канал с буфером 1.",
      "`sync.RWMutex`."
    ],
    "correct_options": [0],
    "explanation": "Атомарные операции выполняются с помощью специальных инструкций процессора и являются самым низкоуровневым и быстрым способом синхронизации для простых операций над примитивными типами. Они избегают накладных расходов на блокировки, переключения контекста и управление горутинами."
  },
  {
    "id": 125,
    "topic": "System Design",
    "question_text": "Что является одной из основных причин использовать gRPC вместо REST/JSON?",
    "options": [
      "Производительность (из-за бинарного протокола Protobuf и HTTP/2) и строгая типизация контрактов.",
      "Простота отладки с помощью браузера.",
      "Лучшая совместимость со старыми системами.",
      "Текстовый, человекочитаемый формат сообщений."
    ],
    "correct_options": [0],
    "explanation": "gRPC выигрывает у REST/JSON в производительности благодаря эффективной бинарной сериализации и мультиплексированию HTTP/2. Кроме того, строго типизированный контракт, определяемый в `.proto` файлах, уменьшает количество ошибок интеграции между сервисами."
  },
  {
    "id": 126,
    "topic": "Arrays and Slices",
    "question_text": "Что произойдет, если срез `s` имеет `len=5` и `cap=5`, и вы выполните `s = append(s, 1)`?",
    "options": [
      "Будет выделен новый базовый массив, и `s` будет указывать на него.",
      "Произойдет паника 'slice bounds out of range'.",
      "Значение `1` будет записано в память за пределами базового массива.",
      "Емкость базового массива будет увеличена на 1."
    ],
    "correct_options": [0],
    "explanation": "Когда `len` среза равен `cap`, в базовом массиве больше нет места. `append` аллоцирует новый, более просторный массив, копирует туда старые 5 элементов, добавляет новый элемент `1`, и возвращает новый заголовок среза, указывающий на эту новую память."
  },
  {
    "id": 127,
    "topic": "Arrays and Slices",
    "question_text": "Каков результат `copy(dst, src)` если `len(dst)` меньше `len(src)`?",
    "options": [
      "Будет скопировано `len(dst)` элементов из `src` в `dst`.",
      "Произойдет паника.",
      "`dst` будет расширен до размера `src`.",
      "Будет скопировано `len(src)` элементов, что приведет к записи за пределы `dst`."
    ],
    "correct_options": [0],
    "explanation": "Встроенная функция `copy` безопасна. Она копирует минимальное количество элементов из `len(dst)` и `len(src)`. Если срез-приемник меньше, будут скопированы только те элементы, которые в него помещаются."
  },
  {
    "id": 128,
    "topic": "Arrays and Slices",
    "question_text": "Если два среза `s1` и `s2` указывают на один и тот же базовый массив, как можно создать `s3`, который является копией `s1`, но с новым, независимым базовым массивом?",
    "options": [
      "Использовать `s3 := make([]int, len(s1)); copy(s3, s1)` или `s3 := append([]int(nil), s1...)`.",
      "`s3 := s1`",
      "`s3 := s1[:]`",
      "Это невозможно, связь с базовым массивом неразрывна."
    ],
    "correct_options": [0],
    "explanation": "Простое присваивание или создание нового среза копирует только заголовок. Чтобы создать настоящую, 'глубокую' копию, нужно явно выделить новый массив (через `make`) и скопировать в него данные (через `copy`). Трюк с `append` к `nil`-срезу достигает того же результата."
  },
  {
    "id": 129,
    "topic": "Strings and Runes",
    "question_text": "Что выведет код: `r := 'a'; fmt.Printf(\"%T\", r)`?",
    "options": [
      "`int32`",
      "`rune`",
      "`string`",
      "`byte`"
    ],
    "correct_options": [0],
    "explanation": "Символьные литералы в одинарных кавычках в Go имеют тип `rune`, который является псевдонимом (alias) для `int32`. `fmt` покажет базовый тип, то есть `int32`."
  },
  {
    "id": 130,
    "topic": "Strings and Runes",
    "question_text": "В каких случаях использование `*string` (указателя на строку) может быть оправдано?",
    "options": [
      "Когда нужно, чтобы функция могла изменить строковую переменную в вызывающей стороне.",
      "Когда нужно представить опциональное строковое значение (различить `\"\"` и `nil`).",
      "Для повышения производительности при передаче очень больших строк.",
      "Оба варианта про изменение переменной и опциональное значение верны."
    ],
    "correct_options": [3],
    "explanation": "Передача `string` по значению уже эффективна. `*string` используется редко, в основном для 'out' параметров (когда функция должна вернуть строку через аргумент) или для представления трех состояний: строка со значением, пустая строка, и отсутствие значения (`nil`)."
  },
  {
    "id": 131,
    "topic": "Maps",
    "question_text": "Можно ли безопасно читать из `nil`-карты?",
    "options": [
      "Да, чтение из `nil`-карты всегда возвращает нулевое значение и не вызывает панику.",
      "Нет, это вызывает панику.",
      "Только если используется форма `val, ok := m[key]`.",
      "Только если карта имеет тип `map[string]string`."
    ],
    "correct_options": [0],
    "explanation": "В отличие от записи, чтение из `nil`-карты является безопасной операцией. Она ведет себя так же, как чтение по несуществующему ключу из не-`nil` карты: возвращает нулевое значение для типа-значения."
  },
  {
    "id": 132,
    "topic": "Maps",
    "question_text": "Какова амортизированная временная сложность операций вставки, поиска и удаления в `map`?",
    "options": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ],
    "correct_options": [0],
    "explanation": "Благодаря использованию хеш-таблицы, средняя сложность основных операций с картой является константной, O(1). В худшем случае (при массовых коллизиях) она может деградировать до O(n), но это крайне редкая ситуация."
  },
  {
    "id": 133,
    "topic": "Interfaces",
    "question_text": "Какая из этих стандартных библиотечных сущностей является интерфейсом?",
    "options": [
      "`error`",
      "`os.File`",
      "`time.Time`",
      "`[]byte`"
    ],
    "correct_options": [0],
    "explanation": "`error` — это встроенный в язык интерфейс, который требует реализации одного метода `Error() string`. Остальные — это конкретные типы (структура, структура и срез)."
  },
  {
    "id": 134,
    "topic": "Interfaces",
    "question_text": "Если структура `S` реализует интерфейс `I`, может ли `[]S` быть присвоен переменной типа `[]I`?",
    "options": [
      "Нет, эти типы несовместимы в Go.",
      "Да, это стандартный полиморфизм.",
      "Только если `S` не содержит указателей.",
      "Только через явное преобразование типов."
    ],
    "correct_options": [0],
    "explanation": "Go не поддерживает ковариантность для срезов. `[]S` и `[]I` имеют разное представление в памяти. Чтобы преобразовать `[]S` в `[]I`, нужно создать новый срез и поэлементно скопировать значения, упаковав каждое в интерфейс."
  },
  {
    "id": 135,
    "topic": "Memory Management",
    "question_text": "Что такое `mcache` в аллокаторе памяти Go?",
    "options": [
      "Кеш свободных `mspan`-ов для одного процессора (P), обеспечивающий выделение памяти без блокировок.",
      "Глобальный кеш памяти.",
      "Кеш, используемый для хранения скомпилированного кода.",
      "Часть стека горутины."
    ],
    "correct_options": [0],
    "explanation": "Каждый процессор P имеет свой `mcache`. Когда горутине на этом P нужна память, она в первую очередь пытается получить ее из `mcache`. Так как к `mcache` имеет доступ только один поток в один момент времени, аллокации происходят очень быстро, без использования мьютексов."
  },
  {
    "id": 136,
    "topic": "Memory Management",
    "question_text": "Когда GC в Go возвращает память операционной системе?",
    "options": [
      "Периодически, если большие области памяти (арены) остаются неиспользованными в течение некоторого времени.",
      "Никогда, вся запрошенная память остается у процесса до его завершения.",
      "Сразу после каждой фазы очистки (Sweep).",
      "Только при вызове `runtime.FreeOSMemory()`."
    ],
    "correct_options": [0],
    "explanation": "Go не спешит возвращать память ОС. Однако, фоновый процесс `sysmon` периодически сканирует кучу, и если находит большие непрерывные участки памяти, которые были свободны в течение нескольких минут, он может вернуть их операционной системе с помощью системного вызова `madvise`."
  },
  {
    "id": 137,
    "topic": "Concurrency",
    "question_text": "Что такое 'неблокирующая' операция с каналом?",
    "options": [
      "Использование `select` с `default` для попытки чтения/записи без ожидания.",
      "Чтение из закрытого канала.",
      "Запись в буферизованный канал, в котором есть место.",
      "Все перечисленное верно."
    ],
    "correct_options": [3],
    "explanation": "Неблокирующая операция — это та, которая завершается немедленно. Все три варианта подходят под это определение: `select` с `default` проверяет и идет дальше; чтение из закрытого канала сразу возвращает нулевое значение; запись в неполный буферизованный канал также происходит мгновенно."
  },
  {
    "id": 138,
    "topic": "Concurrency",
    "question_text": "Каков размер буфера у канала, созданного как `make(chan int)`?",
    "options": [
      "0",
      "1",
      "Зависит от архитектуры.",
      "Неограниченный."
    ],
    "correct_options": [0],
    "explanation": "Если размер буфера не указан, создается небуферизованный (синхронный) канал. Его буфер имеет размер 0, что и заставляет отправителя и получателя синхронизироваться для обмена данными."
  },
  {
    "id": 139,
    "topic": "Concurrency",
    "question_text": "Как можно корректно остановить горутину, выполняющую длительную работу в цикле?",
    "options": [
      "Использовать `select` для проверки канала `done` (или `context.Done()`) на каждой итерации цикла.",
      "Вызвать `runtime.Goexit()` из другой горутины.",
      "Удалить горутину из планировщика.",
      "В Go нет механизма для принудительной остановки горутины извне."
    ],
    "correct_options": [0],
    "explanation": "В Go принята модель кооперативной отмены. Горутина должна сама периодически проверять, не пора ли ей завершиться. Идиоматичный способ — это `select` с проверкой канала, который будет закрыт, когда потребуется остановить работу."
  },
  {
    "id": 140,
    "topic": "System Design",
    "question_text": "Какой паттерн проектирования используется для создания сложных объектов пошагово, позволяя получить разные представления объекта на выходе?",
    "options": [
      "Строитель (Builder).",
      "Фабричный метод (Factory Method).",
      "Прототип (Prototype).",
      "Синглтон (Singleton)."
    ],
    "correct_options": [0],
    "explanation": "Паттерн 'Строитель' отделяет процесс конструирования сложного объекта от его представления. Он позволяет использовать один и тот же процесс сборки для создания различных конфигураций объекта, что особенно полезно при большом количестве полей или опций."
  },
  {
    "id": 141,
    "topic": "System Design",
    "question_text": "Что такое ACID в контексте баз данных?",
    "options": [
      "Набор свойств, гарантирующих надежность транзакций: Атомарность, Согласованность, Изолированность, Долговечность.",
      "Язык запросов к базам данных.",
      "Тип нереляционной базы данных.",
      "Алгоритм для репликации данных."
    ],
    "correct_options": [0],
    "explanation": "ACID — это акроним, описывающий гарантии, которые предоставляет транзакционная система: Atomicity (Атомарность), Consistency (Согласованность), Isolation (Изолированность), Durability (Долговечность)."
  },
  {
    "id": 142,
    "topic": "Arrays and Slices",
    "question_text": "Что выведет код: `a := [...]int{1,2,3}; b := a; b[0] = 9; fmt.Println(a[0])`?",
    "options": [
      "1",
      "9",
      "Произойдет ошибка.",
      "3"
    ],
    "correct_options": [0],
    "explanation": "`a` — это массив. Присваивание `b := a` создает полную копию массива `a`. Переменные `a` и `b` независимы. Изменение `b` никак не влияет на `a`."
  },
  {
    "id": 143,
    "topic": "Strings and Runes",
    "question_text": "Какой пакет стандартной библиотеки Go содержит функции для работы с UTF-8 строками?",
    "options": [
      "`unicode/utf8`",
      "`strings`",
      "`bytes`",
      "`fmt`"
    ],
    "correct_options": [0],
    "explanation": "Пакет `unicode/utf8` предоставляет низкоуровневые функции для работы с кодировкой UTF-8, такие как `DecodeRuneInString` или `RuneCountInString`. Пакет `strings` работает на более высоком уровне абстракции."
  },
  {
    "id": 144,
    "topic": "Maps",
    "question_text": "Что произойдет, если в цикле `for k, v := range myMap` вы удалите элемент, который еще не был посещен итератором?",
    "options": [
      "Этот элемент не появится в последующих итерациях.",
      "Произойдет паника.",
      "Поведение не определено.",
      "Цикл завершится немедленно."
    ],
    "correct_options": [0],
    "explanation": "Спецификация языка гарантирует, что если элемент удаляется во время итерации до того, как итератор до него дошел, то этот элемент не будет возвращен циклом. Это предсказуемое поведение."
  },
  {
    "id": 145,
    "topic": "Interfaces",
    "question_text": "Если функция принимает `io.Reader`, что из этого можно в нее передать? (несколько вариантов)",
    "options": [
      "`os.File` (после открытия файла)",
      "`strings.Reader`",
      "Тело входящего HTTP-запроса (`http.Request.Body`)",
      "Все перечисленное."
    ],
    "correct_options": [3],
    "explanation": "Все эти типы (`*os.File`, `*strings.Reader`, `http.Request.Body`) реализуют метод `Read(p []byte) (n int, err error)` и, следовательно, удовлетворяют интерфейсу `io.Reader`. Это демонстрирует мощь и гибкость интерфейсов в Go."
  },
  {
    "id": 146,
    "topic": "Memory Management",
    "question_text": "Выберите верное утверждение об иерархии памяти компьютера от самой быстрой к самой медленной.",
    "options": [
      "Регистры -> Кеш L1/L2/L3 -> RAM -> SSD/HDD.",
      "RAM -> Кеш L1/L2/L3 -> Регистры -> SSD/HDD.",
      "SSD/HDD -> RAM -> Кеш -> Регистры.",
      "Кеш L1 -> RAM -> L2 -> L3 -> Регистры."
    ],
    "correct_options": [0],
    "explanation": "Иерархия памяти построена так, что чем ближе память к процессору, тем она быстрее, но и меньше по объему. Самые быстрые — регистры ЦП, затем несколько уровней кеша, затем оперативная память (RAM) и, наконец, постоянные накопители."
  },
  {
    "id": 147,
    "topic": "Concurrency",
    "question_text": "Что такое `GOMAXPROCS`?",
    "options": [
      "Переменная, определяющая максимальное количество потоков ОС (M), которые могут одновременно выполнять горутины.",
      "Максимальное количество горутин, которое можно запустить.",
      "Максимальный размер стека для одной горутины.",
      "Количество процессоров P, доступных планировщику."
    ],
    "correct_options": [0],
    "explanation": "`GOMAXPROCS` ограничивает количество потоков ОС, которые могут активно исполнять код Go. Это напрямую влияет на количество процессоров P. По сути, эта переменная определяет степень параллелизма, доступную для вашей программы."
  },
  {
    "id": 148,
    "topic": "Concurrency",
    "question_text": "Можно ли прочитать значение из канала, не удаляя его оттуда?",
    "options": [
      "Нет, операция чтения `<-ch` всегда извлекает значение из канала.",
      "Да, с помощью специального синтаксиса `peek(ch)`.",
      "Да, если канал буферизованный.",
      "Только если канал закрыт."
    ],
    "correct_options": [0],
    "explanation": "Каналы в Go работают по принципу очереди FIFO. Операция чтения является деструктивной — она получает значение и удаляет его из канала (или напрямую от отправителя для небуферизованных каналов). Нельзя 'подсмотреть' значение, не забрав его."
  },
  {
    "id": 149,
    "topic": "System Design",
    "question_text": "Какой паттерн используется для изоляции ресурсов, чтобы сбой в одной части системы не привел к отказу всей системы?",
    "options": [
      "Bulkhead (Переборка).",
      "Saga.",
      "Circuit Breaker.",
      "Adapter."
    ],
    "correct_options": [0],
    "explanation": "Паттерн Bulkhead (Переборка) заключается в разделении ресурсов (например, пулов соединений или горутин) для разных частей системы или зависимостей. Если одна зависимость начинает сбоить и исчерпывает свои ресурсы, это не затрагивает ресурсы, выделенные для других."
  },
  {
    "id": 150,
    "topic": "System Design",
    "question_text": "Что такое `defer` в Go?",
    "options": [
      "Инструкция, которая регистрирует вызов функции для выполнения в момент, когда окружающая функция завершается.",
      "Способ выполнить функцию в фоновом режиме.",
      "Аналог `try...catch` для обработки ошибок.",
      "Оператор для задержки выполнения на определенное время."
    ],
    "correct_options": [0],
    "explanation": "`defer` гарантирует, что вызов функции произойдет перед тем, как содержащая его функция вернет управление. Вызовы `defer` выполняются в порядке LIFO (Last-In, First-Out). Это очень удобно для освобождения ресурсов, таких как закрытие файлов или разблокировка мьютексов."
  }
];